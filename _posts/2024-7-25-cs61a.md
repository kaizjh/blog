---
layout: post
#标题配置
title:  CS61A
#时间配置
date:   2024-07-25 23:16:03 +0800
#大类配置
categories: 国外网课
#小类配置
tag: 教程
#设置文章置顶
topping: false
---

* content
{:toc}

大概是6月7日开始的CS61A的学习，7月25日结束
本课程主要使用Python语言，最后部分了解到了一些Scheme语言的内容



学习笔记摘录
====================================

Building Abstractions with Functions
----------
We have identified in Python some of the elements that must appear in any powerful programming language:
1. Numbers and arithmetic operations are primitive built-in data values and functions.
2. Nested function application provides a means of combining operations.
3. Binding names to values provides a limited means of abstraction.

This principle -- that the meaning of a function should be independent of the parameter names chosen by its author -- has important consequences for programming languages.

**Functional Abstractions** 
is giving a name to some computational process, and then referring to that process as a whole without worrying about its implementation details.

To master **the use of a functional abstraction**, it is often useful to consider its **three core attributes**. The domain of a function is the set of arguments it can take. The range of a function is the set of values it can return. The intent of a function is the relationship it computes between inputs and output (as well as any side effects it might generate). Understanding functional abstractions via their domain, range, and intent is critical to using them correctly in a complex program.

**Desiging Functions**

Fundamentally, the qualities of good functions all reinforce the idea that functions are abstractions.
1. Each function should have exactly one job.Functions that perform multiple jobs in sequence should be divided into multiple funcitons.
2. Don't repeat yourself is a central tenet of software engineering. If you find yourself copying and pasting a block of code, you have probably found an opportunity for functional abstraction.
3. Functions should be defined generally. Squaring is not in the Python Library precisely because it is a special case of the pow function, which raises numbers to arbitrary powers.

Functions that manipulate functions are called **higher-order functions**. An important strength of high-order function is that it helps function get more arguments.

**Function Decorators**
This is a decorated function:

@trace1 // this is the function decorator
def triple(x):
return 3 * x

and it is identical to:

def triple(x):
,,,,return 3 * x
triple = trace1(triple)

Notice that, "triple = trace1(triple)" has two "triple", but they are not the same function, this will make a **"cycle"**: from triple to trace1 to triple (we can see it more clearly with [visualizer](https://pythontutor.com/render.html#code=def%20trace%28fn%29%3A%0A%20%20%20%20def%20wrapped%28x%29%3A%0A%20%20%20%20%20%20%20%20print%28'-%3E%20',%20fn,%20'%28',%20x,%20'%29'%29%0A%20%20%20%20%20%20%20%20return%20fn%28x%29%0A%20%20%20%20return%20wrapped%0A%20%20%20%20%0Adef%20triple%28x%29%3A%0A%20%20%20%20return%203%20*%20x%0Atriple%20%3D%20trace%28triple%29%0A%0Afor%20i%20in%20range%285%29%3A%0A%20%20%20%20triple%28i%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)).


So, what really matters is making a "cycle", and we can even introduce other functions into this "cycle". For example, 2.8.2 Memoization:
```
>>> counted_fib  =  count(fib)
>>> fib  =  memo(counted_fib)
>>> fib(19)
4181
>>> counted_fib.call_count
20
>>> fib(34)
5702887
>>> counted_fib.call_count
35
```
Notice that, fib ->memo -> counted_fib -> count -> fib (a "cycle", from fib to fib), through two decorators: count() and memo().

**Recursive Functions**
我感觉递归函数（Recursive Function）和数学归纳法有一种微妙的联系：在编写递归函数的时候可以分情况来考虑，base case 和 recursive case；数学归纳法使用过程中也有 base case 和 inductive case（归纳步骤）；两者都是先考虑基础项，再假设 n - 1 项成立（递归函数**相信**前面的结果一定是正确的），最后得到我们需要的第 n 项。
---
layout: post
#标题配置
title:  CS61A
#时间配置
date:   2024-07-25 23:16:03 +0800
#大类配置
categories: 国外网课
#小类配置
tag: 教程
#设置文章置顶
topping: false
---

* content
{:toc}

大概是6月7日开始的CS61A的学习，7月25日结束
本课程主要使用Python语言，最后部分了解到了一些Scheme语言的内容



学习笔记摘录
====================================

Building Abstractions with Functions
----------
We have identified in Python some of the elements that must appear in any powerful programming language:
1. Numbers and arithmetic operations are primitive built-in data values and functions.
2. Nested function application provides a means of combining operations.
3. Binding names to values provides a limited means of abstraction.

This principle -- that the meaning of a function should be independent of the parameter names chosen by its author -- has important consequences for programming languages.

**Functional Abstractions** is giving a name to some computational process, and then referring to that process as a whole without worrying about its implementation details.

To master **the use of a functional abstraction**, it is often useful to consider its **three core attributes**. The domain of a function is the set of arguments it can take. The range of a function is the set of values it can return. The intent of a function is the relationship it computes between inputs and output (as well as any side effects it might generate). Understanding functional abstractions via their domain, range, and intent is critical to using them correctly in a complex program.

**Desiging Functions**

Fundamentally, the qualities of good functions all reinforce the idea that functions are abstractions.
1. Each function should have exactly one job.Functions that perform multiple jobs in sequence should be divided into multiple funcitons.
2. Don't repeat yourself is a central tenet of software engineering. If you find yourself copying and pasting a block of code, you have probably found an opportunity for functional abstraction.
3. Functions should be defined generally. Squaring is not in the Python Library precisely because it is a special case of the pow function, which raises numbers to arbitrary powers.

Functions that manipulate functions are called **higher-order functions**. An important strength of high-order function is that it helps function get more arguments.
